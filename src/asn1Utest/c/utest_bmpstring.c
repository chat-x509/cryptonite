/*
 * Copyright (c) 2016 PrivatBank IT <acsk@privatbank.ua>. All rights reserved.
 * Redistribution and modifications are permitted subject to BSD license.
 */

#include "test_utils.h"
#include "utest_asn1.h"

static BMPString_t *test_bmpstring_create(void)
{
    uint8_t encode[28] = {
        0x1e, 0x1a,
        0x00, 0x54, 0x00, 0x65,
        0x00, 0x73, 0x00, 0x74,
        0x00, 0x20, 0x00, 0x6d,
        0x00, 0x65, 0x00, 0x73,
        0x00, 0x73, 0x00, 0x61,
        0x00, 0x67, 0x00, 0x65,
        0x00, 0x2e
    };

    struct asn_dec_rval_s ret;
    BMPString_t *bmpstring = NULL;

    ret = ber_decode(0, &BMPString_desc, (void *)&bmpstring, encode, sizeof(encode));

    ASSERT_RET_OK(ret.code);
    ASSERT_NOT_NULL(bmpstring);

cleanup:
    return bmpstring;
}

void test_bmpstring_alloc_free(void)
{
    BMPString_t *bmpstring = NULL;

    ASSERT_ASN_ALLOC(bmpstring);
    ASSERT_NOT_NULL(bmpstring);
cleanup:
    ASN_FREE(&BMPString_desc, bmpstring);
}

void test_bmpstring_der_encode(void)
{
    ByteArray *actual_ba = NULL;
    ByteArray *expected_ba = NULL;
    uint8_t expected[28] = {
        0x1e, 0x1a,
        0x00, 0x54, 0x00, 0x65,
        0x00, 0x73, 0x00, 0x74,
        0x00, 0x20, 0x00, 0x6d,
        0x00, 0x65, 0x00, 0x73,
        0x00, 0x73, 0x00, 0x61,
        0x00, 0x67, 0x00, 0x65,
        0x00, 0x2e
    };


    BMPString_t *bmpstring = NULL;

    bmpstring = test_bmpstring_create();
    ASSERT_NOT_NULL(bmpstring);
    ASSERT_NOT_NULL(expected_ba = ba_alloc_from_uint8(expected, sizeof(expected)));

    ASSERT_RET_OK(asn_encode_ba(&BMPString_desc, bmpstring, &actual_ba));
    ASSERT_NOT_NULL(actual_ba);

    ASSERT_EQUALS_BA(expected_ba, actual_ba);

cleanup:
    BA_FREE(actual_ba, expected_ba);
    ASN_FREE(&BMPString_desc, bmpstring);
}

void test_bmpstring_uper_encode(void)
{
    asn_enc_rval_t ret;
    uint8_t actual[216] = {0};
    uint8_t expected[216] = {
        0x0d,
        0x00, 0x54, 0x00, 0x65, 0x00, 0x73, 0x00, 0x74,
        0x00, 0x20, 0x00, 0x6d, 0x00, 0x65, 0x00, 0x73,
        0x00, 0x73, 0x00, 0x61, 0x00, 0x67, 0x00, 0x65,
        0x00, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };

    BMPString_t *bmpstring = NULL;

    bmpstring = test_bmpstring_create();
    ASSERT_NOT_NULL(bmpstring);

    ret = uper_encode_to_buffer(&BMPString_desc, bmpstring, (void *)actual, sizeof(actual));
    ASSERT_NOT_NULL(actual);

    ASSERT_TRUE(sizeof(expected) == ret.encoded);
    ASSERT_EQUALS(expected, actual, sizeof(expected));
cleanup:
    ASN_FREE(&BMPString_desc, bmpstring);
}

void test_bmpstring_uper_decode(void)
{
    uint8_t encode[216] = {
        0x0d,
        0x00, 0x54, 0x00, 0x65, 0x00, 0x73, 0x00, 0x74,
        0x00, 0x20, 0x00, 0x6d, 0x00, 0x65, 0x00, 0x73,
        0x00, 0x73, 0x00, 0x61, 0x00, 0x67, 0x00, 0x65,
        0x00, 0x2e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    };

    BMPString_t *actual = NULL;
    BMPString_t *expected = NULL;
    asn_dec_rval_t ret;

    expected = test_bmpstring_create();
    ASSERT_NOT_NULL(expected);

    ret = uper_decode(0, &BMPString_desc, (void *)&actual, encode, sizeof(encode), 0, 0);

    ASSERT_TRUE(ret.code == RET_OK);
    ASSERT_NOT_NULL(actual);

    ASSERT_TRUE(asn_equals(&BMPString_desc, expected, actual));
cleanup:
    ASN_FREE(&BMPString_desc, expected);
    ASN_FREE(&BMPString_desc, actual);
}

void test_bmpstring_xer_decode(void)
{
    uint8_t encode[38] = {
        0x3c, 0x42, 0x4d, 0x50, 0x53, 0x74, 0x72, 0x69,
        0x6e, 0x67, 0x3e, 0x54, 0x65, 0x73, 0x74, 0x20,
        0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x2e,
        0x3c, 0x2f, 0x42, 0x4d, 0x50, 0x53, 0x74, 0x72,
        0x69, 0x6e, 0x67, 0x3e
    };

    BMPString_t *actual = NULL;
    BMPString_t *expected = NULL;
    asn_dec_rval_t ret;

    expected = test_bmpstring_create();
    ASSERT_NOT_NULL(expected);
    ret = xer_decode(0, &BMPString_desc, (void *)&actual, encode, sizeof(encode));

    ASSERT_TRUE(ret.code == RET_OK);
    ASSERT_NOT_NULL(actual);

    asn_equals(&BMPString_desc, expected, actual);
cleanup:
    ASN_FREE(&BMPString_desc, expected);
    ASN_FREE(&BMPString_desc, actual);
}

void utest_bmpstring(void)
{
    PR("%s\n", __FILE__);
    test_bmpstring_alloc_free();
    test_bmpstring_uper_encode();
    test_bmpstring_der_encode();
    test_bmpstring_uper_decode();
    test_bmpstring_xer_decode();
}
